{"version":3,"sources":["cryptojs.js","lib/Crypto.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var Crypto = exports.Crypto = require('./lib/Crypto').Crypto;\n\n[ 'CryptoMath'\n, 'BlockModes'\n, 'DES'\n, 'AES'\n, 'HMAC'\n, 'MARC4'\n, 'MD5'\n, 'PBKDF2'\n, 'PBKDF2Async'\n, 'Rabbit'\n, 'SHA1'\n, 'SHA256'\n].forEach( function (path) {\n\trequire('./lib/' + path);\n});\n","if (typeof Crypto == \"undefined\" || ! Crypto.util)\r\n{\r\n(function(){\r\n\r\nvar base64map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n// Global Crypto object\r\n// with browser window or with node module\r\nvar Crypto = (typeof window === 'undefined') ? exports.Crypto = {} : window.Crypto = {}; \r\n\r\n// Crypto utilities\r\nvar util = Crypto.util = {\r\n\r\n\t// Bit-wise rotate left\r\n\trotl: function (n, b) {\r\n\t\treturn (n << b) | (n >>> (32 - b));\r\n\t},\r\n\r\n\t// Bit-wise rotate right\r\n\trotr: function (n, b) {\r\n\t\treturn (n << (32 - b)) | (n >>> b);\r\n\t},\r\n\r\n\t// Swap big-endian to little-endian and vice versa\r\n\tendian: function (n) {\r\n\r\n\t\t// If number given, swap endian\r\n\t\tif (n.constructor == Number) {\r\n\t\t\treturn util.rotl(n,  8) & 0x00FF00FF |\r\n\t\t\t       util.rotl(n, 24) & 0xFF00FF00;\r\n\t\t}\r\n\r\n\t\t// Else, assume array and swap all items\r\n\t\tfor (var i = 0; i < n.length; i++)\r\n\t\t\tn[i] = util.endian(n[i]);\r\n\t\treturn n;\r\n\r\n\t},\r\n\r\n\t// Generate an array of any length of random bytes\r\n\trandomBytes: function (n) {\r\n\t\tfor (var bytes = []; n > 0; n--)\r\n\t\t\tbytes.push(Math.floor(Math.random() * 256));\r\n\t\treturn bytes;\r\n\t},\r\n\r\n\t// Convert a byte array to big-endian 32-bit words\r\n\tbytesToWords: function (bytes) {\r\n\t\tfor (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\r\n\t\t\twords[b >>> 5] |= (bytes[i] & 0xFF) << (24 - b % 32);\r\n\t\treturn words;\r\n\t},\r\n\r\n\t// Convert big-endian 32-bit words to a byte array\r\n\twordsToBytes: function (words) {\r\n\t\tfor (var bytes = [], b = 0; b < words.length * 32; b += 8)\r\n\t\t\tbytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\r\n\t\treturn bytes;\r\n\t},\r\n\r\n\t// Convert a byte array to a hex string\r\n\tbytesToHex: function (bytes) {\r\n\t\tfor (var hex = [], i = 0; i < bytes.length; i++) {\r\n\t\t\thex.push((bytes[i] >>> 4).toString(16));\r\n\t\t\thex.push((bytes[i] & 0xF).toString(16));\r\n\t\t}\r\n\t\treturn hex.join(\"\");\r\n\t},\r\n\r\n\t// Convert a hex string to a byte array\r\n\thexToBytes: function (hex) {\r\n\t\tfor (var bytes = [], c = 0; c < hex.length; c += 2)\r\n\t\t\tbytes.push(parseInt(hex.substr(c, 2), 16));\r\n\t\treturn bytes;\r\n\t},\r\n\r\n\t// Convert a byte array to a base-64 string\r\n\tbytesToBase64: function (bytes) {\r\n\r\n\t\t// Use browser-native function if it exists\r\n\t\tif (typeof btoa == \"function\") return btoa(Binary.bytesToString(bytes));\r\n\r\n\t\tfor(var base64 = [], i = 0; i < bytes.length; i += 3) {\r\n\t\t\tvar triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n\t\t\tfor (var j = 0; j < 4; j++) {\r\n\t\t\t\tif (i * 8 + j * 6 <= bytes.length * 8)\r\n\t\t\t\t\tbase64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\r\n\t\t\t\telse base64.push(\"=\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn base64.join(\"\");\r\n\r\n\t},\r\n\r\n\t// Convert a base-64 string to a byte array\r\n\tbase64ToBytes: function (base64) {\r\n\r\n\t\t// Use browser-native function if it exists\r\n\t\tif (typeof atob == \"function\") return Binary.stringToBytes(atob(base64));\r\n\r\n\t\t// Remove non-base-64 characters\r\n\t\tbase64 = base64.replace(/[^A-Z0-9+\\/]/ig, \"\");\r\n\r\n\t\tfor (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {\r\n\t\t\tif (imod4 == 0) continue;\r\n\t\t\tbytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) |\r\n\t\t\t           (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\r\n\t\t}\r\n\r\n\t\treturn bytes;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Crypto character encodings\r\nvar charenc = Crypto.charenc = {};\r\n\r\n// UTF-8 encoding\r\nvar UTF8 = charenc.UTF8 = {\r\n\r\n\t// Convert a string to a byte array\r\n\tstringToBytes: function (str) {\r\n\t\treturn Binary.stringToBytes(unescape(encodeURIComponent(str)));\r\n\t},\r\n\r\n\t// Convert a byte array to a string\r\n\tbytesToString: function (bytes) {\r\n\t\treturn decodeURIComponent(escape(Binary.bytesToString(bytes)));\r\n\t}\r\n\r\n};\r\n\r\n// Binary encoding\r\nvar Binary = charenc.Binary = {\r\n\r\n\t// Convert a string to a byte array\r\n\tstringToBytes: function (str) {\r\n\t\tfor (var bytes = [], i = 0; i < str.length; i++)\r\n\t\t\tbytes.push(str.charCodeAt(i) & 0xFF);\r\n\t\treturn bytes;\r\n\t},\r\n\r\n\t// Convert a byte array to a string\r\n\tbytesToString: function (bytes) {\r\n\t\tfor (var str = [], i = 0; i < bytes.length; i++)\r\n\t\t\tstr.push(String.fromCharCode(bytes[i]));\r\n\t\treturn str.join(\"\");\r\n\t}\r\n\r\n};\r\n\r\n})();\r\n}\r\n"]}